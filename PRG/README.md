##随机数生成器报告

本项目使用的随机数为python系统中的os.urandom

本文档将对如何检测该库生成随机数的随机性作出详细说明

本次实验所使用的检测工具是基于Linux开发环境的NIST官方检测工具

从理论上讲，若被检测序列未通过某一随机性检测，可以肯定该序列不随机；但反之，若被检测序列能够通过某一种随机性检测，却不能肯定这个序列是随机的，即通过随机性检测是序列具有随机性的必要非充分条件。因为各检测方法中的检测项目往往都是根据随机序列所表现出的某一方面的特征而设计的。事实上，任何一个由有限种检测项目组成的集合都无法囊括随机性的所有方面。但在实际应用中，如果这个检测的设计对于随机序列使用时的具体要求而言是充分的，且被检测序列又能通过该检测，则认为该序列的随机性是“合格”的。

该软件来自美国国家标准与技术研究所提供的Special Publication800-22测试包（简称NIST随机性测试）。包含十六种检测手段，安装地址为：https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software，安装完成后解压压缩包，之后输入make指令即可完成安装。

运行时，输入: ./access <文件大小>，之后根据提示操作即可。

其中包含的具体检测方法如下：

1.频率检验<br/>
该检验主要是看 0 和 1 在整个序列中所占的比例。检验的目的是确定序列中的 1 和0 数是否与真正的随机序列中的1和 0数近似相同。检验评定1码占1/2，也就是说，在整个序列中0和 1的数目是一样的。其余别的检验手段都是在该检验成立的基础上进行的，并且没有任何证据表明被测序列是不随机的。

2.块内频数检验<br/>
此检验主要是看M位的子块中“1”码的比例。该检验的目的是判定M位的子块内“1”码的频率是否像随机假设下所预期的那样，近似于M/2。当M=1时，该检测相当于检测1位，即频数（一位）检验。

3.游程检验<br/>
此检验主要是看游程的总数，游程指的是一个没有间断的相同数序列，即游程或者是“1111…”或者是“0000…”。一个长度为k 的游程包含k 个相同的位。游程检测的目的是判定不同长度的“1”游程的数目以及“0”游程的数目是否跟理想的随机序列的期望值相一致。具体的讲，就是该检验手段判定在这样的“0”“1”子块之间的振荡是否太快或太慢。

4.块内最长游程检验<br/>
该检验主要是看长度为M-bits的子块中的最长“1”游程。这项检验的目的是判定待检验序列的最长“1”游程的长度是否同随机序列的相同。注意：最长“1”游程长度上的一个不规则变化意味着相应的“0”游程长度上也有一个不规则变化，因此，仅仅对“1”游程进行检验室足够的。

5.二元矩阵秩检验<br/>
该检验主要是看整个序列的分离子矩阵的秩。目的是核对源序列中固定长度子链间的线性依赖关系。
 
6.散傅里叶变换检验<br/>
本检验主要是看对序列进行分步傅里叶变换后的峰值高度。目的是探测待检验信号的周期性，以此揭示其与相应的随机信号之间的偏差程度。做法是观察超过 95%阈值的峰值数目与低于 5%峰值的数目是否有显著不同。
 
7.非重叠模块匹配检验<br/>
此检测主要是看提前设置好的目标数据串发生地次数。目的是探测那些产生太多给出的非周期模式的发生器。对于非重叠模块匹配检验以及后面会谈到的重叠模块匹配检验方法，我们都是使用一个 m-bit 的窗口来搜素一个特定的 m-bit 模式。如果这个模式没有被找到，则窗口向后移动一位。如果模式被发现，则窗口移动到一发现的模式的后一位，重复前面的步骤继续搜素下一个模式。
 
8.重叠模块匹配检验<br/> 
该检验主要是看提前设定的目标模块发生地数目。检验步骤同非重叠模块匹配检验方法大致一样，不同点在于，发现目标模块后，窗口仅向后移动1位，而后继续搜索。

9.Maurer 的通用统计检验<br/>
检验主要是看匹配模块间的bit数。目的是检验序列能否在没有信息损耗的条件下被大大的压缩。一个能被大大压缩的序列被认为是一个非随机序列。
 
10.Lempel-Ziv压缩检验<br/> 
本检测主要是看整个序列中不同模式积累的数目（单词数目）。检验目的是判定待测序列能够被压缩到什么程度。若序列不能被明显的压缩，则该序列就是非随机的。一个随机序列有特征数个不同模式。 

11.线性复杂度检验<br/> 
本检验手段主要是看线性反馈移位寄存器的长度。检验的目的是判定序列的复杂程度是否达到可视为是随 机序列的程度。随机序列的特点是有较长的线性反馈移位寄存器。一个线性反馈移位寄存器太小的话意味着序列非随机。

12.序列检验<br/>
本检验主要是看整个序列中所有可能的重叠m-bit模式的频率，目的是判定  个m-bit重叠模式的数目是否跟随机情况下预期的值相近似。随机序列具有均匀性也就是说对于每个m-bit模式其出现的概率应该是一样的。当m=1时等价于频数检验。
 
13.近似熵检验<br/> 
同序列检验一样，近似熵检验主要看的也是整个序列中所有可能的重叠 m-bit 模式的频率。目的是将两相邻长度(m和m+1)的重叠子块的频数与随机情况下预期的频数相比较。 

14.累加和检验<br/> 
该检验主要是看随机游动的最大偏移。随机游动被定义为序列中调整后的-1，+1的累加和。检验的目的是判定序列的累加和相对于预期的累加和过大还是过小。这个累加和可被看做随机游动。对于随机序列，随机游动的偏离应该在0附近。而对于非随机序列，这个随机游动偏离将会比0大很多。  

15.随机游动检验<br/> 
本检验主要是看一个累加和随机游动中具有 K 个节点的循环的个数。累加和随机游动由于将关于“0”，“1”的部分和序列转化成适当的“-1”、“+1”序列产生的。一个随机游动循环由单位步长的一个序列组成，这个序列的起点和终点均是 0。该检验的目的是确定在一个循环内的特殊状态对应的节点数是否与在随机序列中预计达到的节点数相背离。实际上，这个检验由八个检验（和结论）组成，一个检验和结论对应着一个特定的状态：-4，-3，-2，-1和+1，+2，+3，+4   。

16.随机游动状态频数检验<br/>
该检验主要是看累计和随机游动中经历的特殊状态的总数。检验目的是判定随机游动中实际经历多个状态的值与预期值之间的偏离程度。该检验实际上是十八个检验（和结论），每个状态对应着一个检验和一个结论。这些状态分别是：-9，-8，-7，-6，-5，-4，-3，-2，-1和+1，+2，+3，+4，+5，+6，+7，+8。



测试时用test_random.py生成一个二进制串放入data.dat中，然后用NIST软件来对这个随机二进制串进行检测，检测报告为文件*result.txt*，易见它通过了所有检测，安全性得以证明。


